# This is a high level Documentation for the technical test 



### 1. The Architecture of the system

The codes created in this repository are all based on the system architecture shown in Figure1. 

![screenshot for the webpage](img/figure1.jpg)

#### **Security**

 In order to provide a secure and consolidated infrastructure for our business, I create a two-tier network with 2 public subnets and two private subnets. The application server located in the public subnets are allowed to communicate with the internet while the postgreSQL database in the private subnets are only accesible by the application server in the public subnet.

I have also created three different SGs for ALB, application server and datebase respectively. In doing so, we could make sure that both application and database servers are only allowed to be accessed by specific host and invisible to the public traffic. 

In order to encrypt the crendential file to access AWS cloud and spin up the infrastructure, I have used variables in the code. Feel free to generate your own personal credential for AWS and get you own access key and secret access key.  Then you can type in these two secrets when you use 'terrform plan' or 'terraform apply' to run the code. 

#### **High Availability & Scalability**

An autoscaling group has been created based on the AMI I generated with the existing the web application running in the docker container.  Whenever there is something wrong with one of the front-end application server, asg wil be albe to shut down the broken instance and spin up a brand new one. 

Aslo ALB has been introduced and all the ec2 instances generated by the ASG will automactically be attached to the ALB target group in order the provide the service to the public. The ALB sitting in front of the front-end application servers and are effectively distributing the network traffic to the application server based on the health status of each host.

Besides, the postgreSQL datebase is also provisioned in a highly available way. The Multi-AZ feature is enabled which means another standby replica of the postgreSQL database is provisioned in anohter private subnet in another availability zone.

#### **Automation**

The deployment of the system is consisted of two stages. In the first stage of the deployment, I use terraform code to spin up the infrastructure with one ec2 instance up and running. After running the docker.sh script to build and run the application in a docker container, I am able to create a useful AMI base on the status of the system.  In the later stage, this AMI will be used as the base image to spin up the new ec2 instance.

Then in the second stage of the deployment, I created the asg.tf and alb.tf file to introduce the ASG and ALB resources. We need to create a launch configuration template based on the AMI image we created in the last step. By doing so, the ASG will help to spin up a functional application server and directly serve the incoming traffic should some old instances fail. 

In all, I have created a highly automated and deployable code, and after type in the command 'terraform apply'  to spin up the infrastructure, we can get the endpoint to access the webpage directly.

### 2. The way to run the code 

This terraform code creates an entire VPC network, a postgreSQL database,  launch configuration, auto scaling group and an ALB. The ALB listens on port 80. 

To run, configure your AWS provider as described in <https://www.terraform.io/docs/providers/aws/index.html>

**Running the test code :** 

1. Go to your working directory and type in the command below to download the binary code and rename the repo to  terraform.

```
git clone https://github.com/markwu100/Serviantest.git terraform 
```

2. Initiate the Repository

```
terraform init
```

3. For planning phase

```
terraform plan -var 'access_key={your_access_key}' -var 'secret_access_key={your_secret_key}'
```

4. For apply phase

```
terraform apply -var 'access_key={your_access_key}' -var 'secret_access_key={your_secret_key}'
```

5. After you run the above code you will get the two following outputs. Once the stack is created, wait for few minutes and test the stack by launching a browser with ALB url.  Open a Chrome web browser, and then type in the alb_dns_name listed below, you will then be directed to the landing page of the website. (See the picture show in img directory as Figure2)

```
Outputs:

alb_dns_name = servian-techtest-alb-195736887.ap-southeast-2.elb.amazonaws.com
db_endpoint = demodb-postgres.cc6m3cifzpdr.ap-southeast-2.rds.amazonaws.com:5432
```

6. To remove the stack

```
 terraform destroy  -var 'access_key={your_access_key}' -var 'secret_access_key={your_secret_key}'
```

![screenshot for the webpage](img/figure2.jpg)